import OrderStatistics.*;
import RangeQuery.PrefixSumQuery;
import RangeQuery.SegmentTree;
import Sorting.DearrangementForMinimumSumProductOfTwoArrays;
import Sorting.MedianOfStream;
import Sorting.MinimumSwapsForSortedArray;
import Sorting.SortArrayByFrequencyMaintainingOrder;


public class Main {

    public static void main(String[] args) {

//        // test binary search in rotated and sorted array
//        BSInRotatedNSortedArray bsInRotatedNSortedArray = new BSInRotatedNSortedArray();
//        bsInRotatedNSortedArray.test();
//
//        // test move zeroes to end
//        MoveZeroesToEnd moveZeroesToEnd = new MoveZeroesToEnd();
//        moveZeroesToEnd.test();
//
//        // test three way partitioning
//        ThreeWayPartitioning threeWayPartitioning = new ThreeWayPartitioning();
//        threeWayPartitioning.test();
//
//        // test maximum product subarray
//        MaximumProductSubArray maximumProductSubArray = new MaximumProductSubArray();
//        maximumProductSubArray.test();
//
//        // test minimum operations to make palindrome
//        MinimumOperationToMakePalindrome minimumOperationToMakePalindrome = new MinimumOperationToMakePalindrome();
//        minimumOperationToMakePalindrome.test();
//
//        // test longest span
//        LongestSpanSumTwoBinaryArray longestSpanSumTwoBinaryArray = new LongestSpanSumTwoBinaryArray();
//        longestSpanSumTwoBinaryArray.test();
//
//        // test generate all permutations and subarrays of an array
//        GenerateAllPermutations generateAllPermutations = new GenerateAllPermutations();
//        generateAllPermutations.test();
//
//        // test median in streams of integer
//        MedianOfStream medianOfStream = new MedianOfStream();
//        medianOfStream.test();
//
//        // test find minimum no of swaps to sort an array
//        MinimumSwapsForSortedArray minimumSwapsForSortedArray = new MinimumSwapsForSortedArray();
//        minimumSwapsForSortedArray.test();
//
//        // test minimum no of dearrangements for minimum sum product of two arrays
//        DearrangementForMinimumSumProductOfTwoArrays obj = new DearrangementForMinimumSumProductOfTwoArrays();
//        obj.test();
//
//        // test sort by frequency maintaining order
//        SortArrayByFrequencyMaintainingOrder sortArrayByFrequencyMaintainingOrder = new SortArrayByFrequencyMaintainingOrder();
//        sortArrayByFrequencyMaintainingOrder.test();

//        // test find min and max in an array using tournament method
//        MinMaxTournament minMaxTournament = new MinMaxTournament();
//        minMaxTournament.test();

//        // test maximum sum with no adjacent allowed
//        MaximumSumNoAdjacentAllowed maximumSumNoAdjacentAllowed = new MaximumSumNoAdjacentAllowed();
//        maximumSumNoAdjacentAllowed.test();

//        // test k smallest with maintained order
//        KSmallestInSameOrder kSmallestInSameOrder = new KSmallestInSameOrder();
//        kSmallestInSameOrder.test();


//        // k maximum sum combinations from two arrays
//        KMaximumSumCombinations kMaximumSumCombinations = new KMaximumSumCombinations();
//        kMaximumSumCombinations.test();

//        // test k maximum sum sub arrays non overlapping
//        KMaximumSumSubArrayNonOverlapping kMaximumSumSubArrayNonOverlapping = new KMaximumSumSubArrayNonOverlapping();
//        kMaximumSumSubArrayNonOverlapping.test();

//        // test quick select algorithm
//        QuickSelect quickSelect = new QuickSelect();
//        quickSelect.test();
//
//        // test prefix sum array query
//        PrefixSumQuery prefixSumQuery = new PrefixSumQuery();
//        prefixSumQuery.test();

        // test segment tree
        SegmentTree segmentTree = new SegmentTree();
        segmentTree.test();





    }
}
